#target Illustrator //  script.name = shrinkABtoFitArt_CS4.jsx;//  script.required = one document with at least one piece of art;//  script.parent = carlos canto // 5/3/11;//  script.elegant = false;// The script doesn't like "Compound Shapes" or Groups -- If it can't be a simple Path, you have to make it into a "Compound Path."// For groups, just Ungroup, and use Object > Compound Path > Make// For compound shapes, first use Object > Expand Appearance, then Ungroup (if necessary), then Object > Compound Path > Make// Don't forget to rename your icon before running the export script.var self = this,	rootLayer,	rootLayerWasLocked = false,	baseYOffset = 16,	defaultInset = 6,	testingYOffset = false;Array.prototype.indexOf = Array.prototype.indexOf || function(value, start) {  for (var i = 0, length = this.length; i < length; i++) {    if (this[i] == value) {      return i;    }  }  return -1;}if (app.documents.length > 0){			var doc = app.activeDocument;	var items = doc.selection;	if (items.length >= 1){		var destFolder = null;		destFolder = Folder.selectDialog( 'Select output folder for SVGs' );		// once we have all our input variables, go to it.		if (destFolder != null) {			// if the root layer is locked, record it & unlock it so we can place the trianglePath on it.			rootLayer = doc.layers[0];			if (rootLayer.locked === true){				rootLayerWasLocked = true;				rootLayer.locked = false;			}			var itemsOrderedLR = reorderIconsLeftToRight(items);			// the height of the artboard is used to determine the width/height of the actual-size icon square.			var iconActualSize = getIconSizeFromArtboard(doc.artboards);			var iconSizeEmsX10 = iconActualSize / 16 * 10;			// The actual size of the icon doesn't matter to the font - it's the icon's size in relation to its containing square. So a 15px icon in a 16px container is the same as a 600px icon in a 640px container.			// the iconBigSize is the scaled up pixel dimensions of the icon file. We want it to be up near 1000 pixels - but it has to be a multiple of the iconActualSize.			var scaleToFullSizeRatio = Math.round (1024/iconActualSize);			var iconBigSize = iconActualSize * scaleToFullSizeRatio;			// iconBigSize = 1024; // default inset is 6.			var scaleToFullSizeRatio = iconBigSize / iconActualSize;						// The offsetPathStyle runs "offset path" on the shape, with a negative value, to make a 'light' version of the font, for better rendering in browsers.												var options, targetFile, targetFile2;				// Get the SVG options to be used.			options = self.getOptions();			// You can tune these by changing the code in the getOptions() function.			// go through all the selected itemsOrderedLR			// FOR EACH ICON:			for (var i = 0; i < itemsOrderedLR.length; i++){				var icon = itemsOrderedLR[i];				var nameAndInset = processNameAndInset (icon);				var iconName = nameAndInset.name;				var insetRatio = 16/iconActualSize;				var inset = Math.round(Number(nameAndInset.inset) * insetRatio);				// create a tempDoc to store a single icon to save as a svg.				var tempDoc = app.documents.add(DocumentColorSpace.RGB, iconBigSize, iconBigSize);							// create a trianlePath, to go at the origin (0,0) of the icon, and carry the appearance style to the tempDoc				var trianglePath = createTriangleWithStyle(doc,inset);				trianglePath.duplicate( tempDoc );				// putting the trianglePath into tempDoc does 2 things: 				// 1) copyies the graphicStyle to tempDoc				// 2) places a path at 0,0 so the SVG won't move the icon to the edge. Without this path, the SVG rounds or something, and doesn't keep the icon in the right place on the artboard.				trianglePath.remove(); // remove it from the original doc								// the tranglePath in the temoDoc is now the originPath. Place it at the origin (top-left);				var originPath = tempDoc.pageItems[0];				originPath.top = iconBigSize;				originPath.left = 0;				// var iconXPosRatio = icon.left / iconActualSize;				var iconXPosIndex = Math.floor(icon.left / iconActualSize); // this will give you the number of icons before (left of) this icon in the master sheet.				var iconXPosOffset = iconXPosIndex * iconActualSize; // how far over this icon's bounding box starts.				var iconX = icon.left - (iconXPosOffset); // how many px over the icon is relative to its own bounding box.				// apparently when using a script, it creates the new document with the origin at the bottom-left, even though the IDE has it at top left now. 				// The script also reports the Y position of the original element as negative, even though Illustrator now sees down from top left as positive. So, THAT made this more fun to write!				var yOffset = determineScaledYOffset(iconActualSize);				var tempDocIconScaledX = iconX * scaleToFullSizeRatio;				var tempDocIconScaledY = iconBigSize + (icon.top * scaleToFullSizeRatio) - yOffset;				// copy the icon into the tempDoc				icon.duplicate( tempDoc, ElementPlacement.PLACEATBEGINNING );				var tempDocIcon = tempDoc.pageItems[0];				// scale the icon in the tempDoc.				tempDocIcon.width = tempDocIcon.width * scaleToFullSizeRatio;				tempDocIcon.height = tempDocIcon.height * scaleToFullSizeRatio;												tempDocIcon.top = tempDocIconScaledY;				tempDocIcon.left = tempDocIconScaledX;																				// use "offset path" (by applying the graphicStyle) to make the 'light' icon for better cross-browser rendering.				var tempDocOffsetPathStyle = tempDoc.graphicStyles["OffsetPath-" + inset]; 				tempDocOffsetPathStyle.applyTo(tempDocIcon);				// Set up the file to use to save the document as svg				var index =  (itemsOrderedLR.length - i) * 1;				var indexWithLeadingZero = index<10 ? ("0"+index) : index;				var targetFileName = (100 - iconSizeEmsX10) + "-" + indexWithLeadingZero + "-icon-" + iconSizeEmsX10 + "-" + iconName;				targetFile = this.getTargetFile(targetFileName, '.svg', destFolder);								// Save as SVG & close the tempDoc				tempDoc.exportFile(targetFile, ExportType.SVG, options);						tempDoc.close(SaveOptions.DONOTSAVECHANGES);			}			// reset the rootLayer lock.			if (rootLayerWasLocked === true){				rootLayer.locked = true;			}						// Note: the doc.exportFile function for SVG is actually a Save As			// operation rather than an Export, that is, the document's name			// in Illustrator will change to the result of this call.						} else {			alert("You need to select a valid destination folder.");		}	} else {		alert ("At least one object must be selected.");	}}function determineScaledYOffset(iconActualSize){	var yOffset;	if (testingYOffset){			yOffset = Number(prompt("Vertical Position Offset: ", baseYOffset));	} else {		// I couldn't figure out an equation so we'll just have to set these manually.		if (iconActualSize < 17){			yOffset = 16;		} else if (iconActualSize < 25){			yOffset = 12;		} else if (iconActualSize < 33){			yOffset = 9;		} else if (iconActualSize < 49){			yOffset = 6;		} else if (iconActualSize < 65){			yOffset = 4;		} else if (iconActualSize < 81){			yOffset = "3_5";		} else if (iconActualSize < 97){			yOffset = 3;			// here down are not tested.		} else if (iconActualSize < 129){			yOffset = 2;		} else {			yOffset = 1;		}	}	return yOffset;}function createTriangleWithStyle(doc,inset){	var offsetPathVar = "OffsetPath-" + inset;	var offsetPathStyle = doc.graphicStyles[offsetPathVar];		var trianglePath = rootLayer.pathItems.add();	trianglePath.setEntirePath( Array( Array(0, 0), Array(0, 0.001), Array(0.001,0.001) ) );	trianglePath.closed = true;	offsetPathStyle.applyTo( trianglePath );	return trianglePath;}function getIconSizeFromArtboard(artboards){	var abIndex = artboards.getActiveArtboardIndex(),		ab = artboards[abIndex],		abBounds = ab.artboardRect,		abtop = abBounds[1],		abbottom = abBounds[3],		iconActualSize = Math.abs(abbottom - abtop);	return iconActualSize;}function processNameAndInset (icon) {	var inset,		iconName = icon.name,		iconNameArray = iconName.split("-"),		insetTemp = iconNameArray[0];	// create the new iconName - strip out any number-dash from the beginning if it exists.	if (Number(insetTemp) >= 0){		if (iconNameArray.length > 2){			iconName = "";			for (var i = 1; i < iconNameArray.length; i++){				iconName += iconNameArray[i];				if ((i+1) < iconNameArray.length){					iconName += "-";				}			}		} else {			iconName = iconNameArray[1];		}		if (Number(insetTemp) > 0){				inset = Number(insetTemp);		} else {				inset = 0;		}	} else {		inset = defaultInset;		iconName = icon.name;	}	return {		'name' : iconName,		'inset' : inset	};};function reorderIconsLeftToRight(items){	// reorder icons based on left-to-right order. This keeps their output filenames in sync with their placement in the AI doc.	var itemsArray = [];	for (var i = 0; i < items.length; i++){		// convert items into an actual array, rather than a ai object, so we can use normal array methods.		itemsArray.push(items[i]);	}	// actually do the reordering of icons.	var itemsOrderedLR = [];	while (itemsArray.length > 0){		var leftmostXpos = 1000000;		var leftmostIndx = 0;		for (var i = 0; i < itemsArray.length; i++){			if (itemsArray[i].left < leftmostXpos){				leftmostXpos = itemsArray[i].left;				leftmostIndx = i;			}		}		var objToBePushed = itemsArray[leftmostIndx];		itemsArray.splice(leftmostIndx,1);		itemsOrderedLR.push(objToBePushed);	}	return itemsOrderedLR;}function movePathToDoc3 (path, doc3) {	var thLeft = path.left;	var thTop = path.top;	var doc3path = path.duplicate( doc3 );	doc3path.top = thTop;	doc3path.left = thLeft;	alert("thLeft: " + thLeft + ", thTop: " + thTop);}// ungrouping functions// var itemKinds = new Array("pathItems","compoundPathItems","textFrames","placedItems","rasterItems","meshItems","pluginItems","graphItems","symbolItems","groupItems");function getChildAll(obj){	var childsArr = new Array();	for(var i=0;i<obj.pageItems.length;i++){		childsArr.push(obj.pageItems[i]);	}	return childsArr;}function ungroup(obj){	var elements = getChildAll(obj);	if(elements.length<1){		obj.remove();		return;	}else{		for(var i=0;i<elements.length;i++){			try{				if(elements[i].parent.typename!="Layer"){					elements[i].moveBefore(obj);				}				if(elements[i].typename=="GroupItem" || elements[i].typename=="compoundPathItems"){					ungroup(elements[i]);				}			}catch(e){			}		}	}}/** Returns the options to be used for the generated files.	@return ExportOptionsSVG object*/function getOptions(){	// Create the required options object	var options = new ExportOptionsSVG();	// See ExportOptionsSVG in the JavaScript Reference for available options			// Set the options you want below:		// For example, uncomment to set the compatibility of the generated svg to SVG Tiny 1.1		// options.DTD = SVGDTDVersion.SVGTINY1_1;		// For example, uncomment to embed raster images	// options.embedRasterImages = true;		return options;}/** Returns the file to save or export the document into.	@param docName the name of the document	@param ext the extension the file extension to be applied	@param destFolder the output folder	@return File object*/function getTargetFile(docName, ext, destFolder) {	var fullDocName = docName + ext;		// Create the file object to save to	var myFile = new File( destFolder + '/' + fullDocName );		// Preflight access rights	if (myFile.open("w")) {		// alert("close - disabled.")	}	else {		throw new Error('Access is denied');	}	return myFile;}